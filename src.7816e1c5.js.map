{"version":3,"sources":["src/constants.ts","src/utils/color.ts","src/utils/coords.ts","src/Point.ts","src/Segment.ts","src/Board.ts","src/utils/touch.ts","src/index.ts"],"names":[],"mappings":"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","file":"src.7816e1c5.js","sourceRoot":"..","sourcesContent":["export const ratio = window.devicePixelRatio || 1;\n\nexport const canvasWidth = 200;\nexport const canvasHeight = 200;\n\nexport const columns = 6;\n\nexport const pointArea = canvasWidth / columns * ratio;\nexport const pointSize = pointArea / 4;\n","const colors = {\n  red: 'rgb(242, 50, 12)',\n  blue: 'rgb(25, 135, 252)',\n  green: 'rgb(13, 214, 57)',\n  orange: 'rgb(255, 213, 0)',\n  purple: 'rgb(255, 43, 241)',\n} as const;\n\nexport type Color = typeof colors[keyof typeof  colors] | 'black';\n\nexport const randomColor = (): Color => Object.values(colors)[Math.ceil(Math.random() * 4)];\n","import { columns } from '../constants';\n\nexport const getX = (index: number) => index - (columns * Math.floor(index / columns));\n\nexport const getY = (index: number) => Math.floor(index / columns);\n\nexport const getIndex = (x: number, y: number) => y * columns + x;\n","import { pointSize, pointArea, columns } from './constants';\nimport { Color, randomColor } from './utils/color';\nimport { getX, getY } from './utils/coords';\n\nexport class Point {\n  public x: number;\n  public y: number;\n  public color: Color;\n  public connected: boolean = false;\n\n  private prevY?: number;\n\n  constructor(index: number) {\n    this.x = getX(index - (columns * columns));\n    this.y = getY(index - (columns * columns));\n\n    this.moveTo(index)\n\n    this.color = randomColor();\n  }\n\n  get actualCoords(): { x: number, y: number } {\n    return {\n      x: this.x * pointArea + pointArea / 2,\n      y: this.y * pointArea + pointArea / 2\n    };\n  }\n\n  setConnected(state: boolean) {\n    this.connected = state;\n  }\n\n  render(ctx: CanvasRenderingContext2D) {\n    ctx.fillStyle = this.color;\n\n    const coords = this.actualCoords;\n\n    if (this.prevY !== undefined) {\n      coords.y = this.prevY;\n      this.prevY = this.prevY + (this.actualCoords.y - this.prevY) / 3;\n    }\n\n    if (this.prevY !== undefined && this.prevY >= this.actualCoords.y) {\n      this.prevY = undefined;\n    }\n\n    if (this.connected) {\n      ctx.globalAlpha = 0.2;\n\n      const shadow = new Path2D();\n      shadow.arc(\n        coords.x,\n        coords.y,\n        pointSize + 4,\n        0,\n        2 * Math.PI\n      );\n\n      ctx.fill(shadow);\n\n      ctx.globalAlpha = 1;\n    }\n\n    const point = new Path2D();\n    point.arc(\n      coords.x,\n      coords.y,\n      pointSize,\n      0,\n      2 * Math.PI\n    );\n\n    ctx.fill(point);\n  }\n\n  moveTo(index: number) {\n    this.prevY = this.actualCoords.y;\n\n    this.x = getX(index);\n    this.y = getY(index);\n  }\n\n  isSibling(point: Point) {\n    if (this.x === point.x && Math.abs(this.y - point.y) === 1) {\n      return true;\n    }\n\n    if (this.y === point.y && Math.abs(this.x - point.x) === 1) {\n      return true;\n    }\n  }\n}\n","import { ratio } from './constants';\n\ninterface Coordinates {\n  x: number;\n  y: number;\n}\n\nexport class Segment {\n  constructor(\n    public from: Coordinates,\n    public to: Coordinates,\n  ) {}\n\n  render(ctx: CanvasRenderingContext2D, color: string) {\n    ctx.strokeStyle = color;\n    ctx.lineWidth = ratio * 2;\n\n    ctx.beginPath();\n    ctx.moveTo(this.from.x, this.from.y);\n    ctx.lineTo(this.to.x, this.to.y);\n    ctx.stroke();\n  }\n}","import { columns, pointArea, ratio } from './constants';\nimport { Point } from './Point';\nimport { Segment } from './Segment';\nimport { Color } from './utils/color';\nimport { getIndex } from './utils/coords';\n\nexport class Board {\n  private points: Array<Point | undefined>;\n  private segments: Array<Segment> = [];\n\n  public activeColor: Color = 'black';\n\n  constructor(\n    public ctx: CanvasRenderingContext2D,\n    public width: number,\n    public height: number,\n  ) {\n    this.points = Array.from({ length: columns * columns }, (_, index) => new Point(index));\n  }\n\n  get lastSegment() {\n    return this.segments[this.segments.length - 1];\n  }\n\n  handleStart = ({ offsetX, offsetY }: { offsetX: number, offsetY: number }) => {\n    const point = this.getPoint(offsetX * ratio, offsetY * ratio);\n\n    if (!point) {\n      return;\n    }\n\n    point.setConnected(true);\n\n    const start = point.actualCoords;\n\n    this.segments.push(new Segment(\n      start,\n      { x: offsetX * ratio, y: offsetY * ratio },\n    ));\n\n    this.activeColor = point.color;\n  }\n\n  handleMove = ({ offsetX, offsetY }: { offsetX: number, offsetY: number }) => {\n    if (!this.segments.length) {\n      return;\n    }\n\n    const x = offsetX * ratio;\n    const y = offsetY * ratio;\n\n    this.lastSegment.to = { x, y };\n\n    this.resolveAction(x, y);\n\n    if (this.isLoop()) {\n      this.connectAll();\n    }\n  }\n\n  handleEnd = () => {\n    this.removeSelected();\n    this.movePointsToNewIndeces();\n    this.fillBoard();\n\n    this.points.forEach(p => p && p.setConnected(false));\n    this.segments = [];\n\n    this.activeColor = 'black';\n  }\n\n  render() {\n    this.ctx.fillStyle = 'rgb(255, 255, 255)';\n    this.ctx.fillRect(0, 0, this.width * ratio, this.height * ratio);\n\n    this.points.forEach(p => p && p.render(this.ctx));\n    this.segments.forEach(s => s.render(this.ctx, this.activeColor));\n  }\n\n  getPoint(offsetX: number, offsetY: number): Point | undefined {\n    const x = Math.floor(offsetX / pointArea);\n    const y = Math.floor(offsetY / pointArea);\n\n    const index = getIndex(x, y);\n\n    return this.points[index];\n  }\n\n  resolveAction(x: number, y: number) {\n    const prevPoint = this.getPoint(this.lastSegment.from.x, this.lastSegment.from.y);\n    const nextPoint = this.getPoint(x, y);\n\n    if (!prevPoint || !nextPoint) {\n      return;\n    }\n\n    if (prevPoint === nextPoint) {\n      return;\n    }\n\n    const connectable = prevPoint.isSibling(nextPoint) && prevPoint.color === nextPoint.color;\n\n    if (!connectable) {\n      return;\n    }\n\n    if (this.isBackwards(nextPoint)) {\n      return this.disconnect(prevPoint);\n    }\n\n    return this.connect(nextPoint);\n  }\n\n  isBackwards(point: Point) {\n    if (this.segments.length < 2) {\n      return false;\n    }\n\n    const prevSegment = this.segments[this.segments.length - 2];\n\n    const to = point.actualCoords;\n\n    return prevSegment.from.x === to.x && prevSegment.from.y === to.y;\n  }\n\n  isLoop() {\n    return this.segments\n      .slice(0, this.segments.length - 1)\n      .some(segment => segment.from.x === this.lastSegment.from.x && segment.from.y === this.lastSegment.from.y);\n  }\n\n  connectAll() {\n    this.points.forEach(point => {\n      if (point && point.color === this.activeColor) {\n        point.setConnected(true);\n      }\n    });\n  }\n\n  connect(point: Point) {\n    point.setConnected(true);\n\n    const to = point.actualCoords;\n\n    this.lastSegment.to = to;\n\n    this.segments.push(new Segment(\n      { ...this.lastSegment.to },\n      { ...this.lastSegment.to },\n    ));\n  }\n\n  disconnect(nextPoint: Point) {\n    nextPoint.setConnected(false);\n\n    this.segments.pop();\n  }\n\n  removeSelected() {\n    const connected = this.points.filter(point => point && point.connected).length;\n\n    if (connected < 2) {\n      return;\n    }\n\n    this.points.forEach((point, index) => {\n      if (point && point.connected) {\n        this.points[index] = undefined;\n      }\n    });\n  }\n\n  movePointsToNewIndeces() {\n    let q: number[] = [];\n\n\n    for (let x = columns - 1; x >= 0; x--) {\n      q = [];\n\n      for (let y = columns - 1; y >= 0; y--) {\n        const index = getIndex(x, y);\n        const point = this.points[index];\n\n        if (!point) {\n          q.push(index);\n          continue;\n        }\n\n        if (q.length) {\n          const lastIndex = q.shift() as number;\n\n          point.moveTo(lastIndex);\n          this.points[lastIndex] = point;\n\n          q.push(index);\n          this.points[index] = undefined;\n        }\n      }\n    }\n  }\n\n  fillBoard() {\n    this.points.forEach((point, index) => {\n      if (point) {\n        return;\n      }\n\n      this.points[index] = new Point(index);\n    });\n  }\n}","export function handleTouchStart(event: TouchEvent) {\n  event.preventDefault();\n\n  const canvas = event.target as HTMLCanvasElement;\n\n  if (!canvas) {\n    throw new Error('Canvas is undefiend');\n  }\n\n  return touchPosition(canvas, event.touches[0]);\n}\n\nexport function handleTouchMove(event: TouchEvent) {\n  event.preventDefault();\n\n  const canvas = event.target as HTMLCanvasElement;\n\n  if (!canvas) {\n    throw new Error('Canvas is undefiend');\n  }\n\n  return touchPosition(canvas, event.changedTouches[0]);\n}\n\nlet canvasRect: DOMRect | undefined;\n\nfunction touchPosition(canvas: HTMLCanvasElement, touch: Touch) {\n  if (!canvasRect) {\n    canvasRect = canvas.getBoundingClientRect();\n  }\n\n  return {\n    offsetX: touch.pageX - canvasRect.left,\n    offsetY: touch.pageY - canvasRect.top\n  };\n}","import { canvasWidth, canvasHeight, ratio} from './constants';\nimport { Board } from './Board';\nimport { handleTouchMove, handleTouchStart } from './utils/touch';\n\n(function main() {\n  const canvas = document.querySelector<HTMLCanvasElement>('#canvas');\n\n  if (!canvas) {\n    return;\n  }\n\n  canvas.setAttribute('width', String(canvasWidth * ratio));\n  canvas.setAttribute('height', String(canvasHeight * ratio));\n  canvas.style.width = `${canvasWidth}px`;\n  canvas.style.height = `${canvasHeight}px`;\n\n  const ctx = canvas.getContext('2d');\n\n  if (!ctx) {\n    return;\n  }\n\n  const board = new Board(ctx, canvasWidth, canvasHeight);\n\n  console.log(board);\n\n  canvas.addEventListener('mousedown', board.handleStart, false);\n  canvas.addEventListener('mousemove', board.handleMove, false);\n  canvas.addEventListener('mouseup', board.handleEnd, false);\n\n  canvas.addEventListener('touchstart', event => board.handleStart(handleTouchStart(event)), false);\n  canvas.addEventListener('touchmove', event => board.handleMove(handleTouchMove(event)), false);\n  canvas.addEventListener('touchend', board.handleEnd, false);\n  canvas.addEventListener('touchcancel', board.handleEnd, false);\n\n  render(board);\n})();\n\nfunction render(board: Board) {\n  board.render();\n\n  requestAnimationFrame(render.bind(null, board));\n}\n"]}